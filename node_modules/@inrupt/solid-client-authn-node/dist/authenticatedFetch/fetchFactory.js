"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildDpopFetch = exports.createDpopHeader = exports.normalizeHttpUriClaim = exports.buildBearerFetch = void 0;
const jose_1 = require("jose");
const cross_fetch_1 = require("cross-fetch");
const uuid_1 = require("uuid");
function isExpectedAuthError(statusCode) {
    return [401, 403].includes(statusCode);
}
function buildBearerFetch(accessToken, refreshOptions) {
    let currentAccessToken = accessToken;
    const currentRefreshOptions = refreshOptions
        ? { ...refreshOptions }
        : undefined;
    return async (init, options) => {
        const response = await cross_fetch_1.fetch(init, {
            ...options,
            headers: {
                ...options === null || options === void 0 ? void 0 : options.headers,
                Authorization: `Bearer ${currentAccessToken}`,
            },
        });
        if (!isExpectedAuthError(response.status) ||
            currentRefreshOptions === undefined) {
            return response;
        }
        try {
            const tokenSet = await currentRefreshOptions.tokenRefresher.refresh(currentRefreshOptions.sessionId, currentRefreshOptions.refreshToken);
            currentAccessToken = tokenSet.access_token;
            if (tokenSet.refresh_token) {
                currentRefreshOptions.refreshToken = tokenSet.refresh_token;
            }
            return cross_fetch_1.fetch(init, {
                ...options,
                headers: {
                    ...options === null || options === void 0 ? void 0 : options.headers,
                    Authorization: `Bearer ${currentAccessToken}`,
                },
            });
        }
        catch (e) {
            return response;
        }
    };
}
exports.buildBearerFetch = buildBearerFetch;
function normalizeHttpUriClaim(audience) {
    const cleanedAudience = new URL(audience);
    cleanedAudience.hash = "";
    cleanedAudience.username = "";
    cleanedAudience.password = "";
    return cleanedAudience.toString();
}
exports.normalizeHttpUriClaim = normalizeHttpUriClaim;
function createDpopHeader(audience, method, key) {
    return jose_1.JWT.sign({
        htu: normalizeHttpUriClaim(audience),
        htm: method.toUpperCase(),
        jti: uuid_1.v4(),
    }, key, {
        header: {
            jwk: key.toJWK(false),
            typ: "dpop+jwt",
        },
        algorithm: "ES256",
    });
}
exports.createDpopHeader = createDpopHeader;
async function buildDpopFetchOptions(targetUrl, authToken, dpopKey, defaultOptions) {
    var _a;
    const options = { ...defaultOptions };
    options.headers = {
        ...defaultOptions === null || defaultOptions === void 0 ? void 0 : defaultOptions.headers,
        Authorization: `DPoP ${authToken}`,
        DPoP: createDpopHeader(targetUrl, (_a = defaultOptions === null || defaultOptions === void 0 ? void 0 : defaultOptions.method) !== null && _a !== void 0 ? _a : "get", dpopKey),
    };
    return options;
}
async function buildDpopFetch(accessToken, dpopKey, refreshOptions) {
    let currentAccessToken = accessToken;
    const currentRefreshOptions = refreshOptions;
    return async (url, options) => {
        let response = await cross_fetch_1.fetch(url, await buildDpopFetchOptions(url.toString(), currentAccessToken, dpopKey, options));
        const failedButNotExpectedAuthError = !response.ok && !isExpectedAuthError(response.status);
        const hasBeenRedirected = response.url !== url;
        if (response.ok || failedButNotExpectedAuthError) {
            return response;
        }
        if (hasBeenRedirected) {
            response = await cross_fetch_1.fetch(response.url, await buildDpopFetchOptions(response.url, currentAccessToken, dpopKey, options));
        }
        if (currentRefreshOptions !== undefined &&
            isExpectedAuthError(response.status)) {
            try {
                const tokenSet = await currentRefreshOptions.tokenRefresher.refresh(currentRefreshOptions.sessionId, currentRefreshOptions.refreshToken, dpopKey);
                currentAccessToken = tokenSet.access_token;
                if (tokenSet.refresh_token) {
                    currentRefreshOptions.refreshToken = tokenSet.refresh_token;
                }
                return cross_fetch_1.fetch(url.toString(), await buildDpopFetchOptions(url.toString(), currentAccessToken, dpopKey, options));
            }
            catch (e) {
                return response;
            }
        }
        return response;
    };
}
exports.buildDpopFetch = buildDpopFetch;
//# sourceMappingURL=fetchFactory.js.map