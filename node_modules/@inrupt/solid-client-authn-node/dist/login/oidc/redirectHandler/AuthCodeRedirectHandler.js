"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AuthCodeRedirectHandler = exports.getWebidFromTokenPayload = void 0;
const tsyringe_1 = require("tsyringe");
const solid_client_authn_core_1 = require("@inrupt/solid-client-authn-core");
const url_1 = require("url");
const openid_client_1 = require("openid-client");
const jose_1 = require("jose");
const IssuerConfigFetcher_1 = require("../IssuerConfigFetcher");
const fetchFactory_1 = require("../../../authenticatedFetch/fetchFactory");
async function getWebidFromTokenPayload(idToken) {
    if (idToken.webid !== undefined && typeof idToken.webid === "string") {
        return idToken.webid;
    }
    try {
        const webid = new url_1.URL(idToken.sub);
        return webid.href;
    }
    catch (e) {
        throw new Error(`The ID token has no 'webid' claim, and its 'sub' claim of [${idToken.sub}] is invalid as a URL - error [${e}].`);
    }
}
exports.getWebidFromTokenPayload = getWebidFromTokenPayload;
let AuthCodeRedirectHandler = class AuthCodeRedirectHandler {
    constructor(storageUtility, sessionInfoManager, issuerConfigFetcher, clientRegistrar, tokenRefresher) {
        this.storageUtility = storageUtility;
        this.sessionInfoManager = sessionInfoManager;
        this.issuerConfigFetcher = issuerConfigFetcher;
        this.clientRegistrar = clientRegistrar;
        this.tokenRefresher = tokenRefresher;
    }
    async canHandle(redirectUrl) {
        try {
            const myUrl = new url_1.URL(redirectUrl);
            return (myUrl.searchParams.get("code") !== null &&
                myUrl.searchParams.get("state") !== null);
        }
        catch (e) {
            throw new Error(`[${redirectUrl}] is not a valid URL, and cannot be used as a redirect URL: ${e.toString()}`);
        }
    }
    async handle(inputRedirectUrl) {
        if (!(await this.canHandle(inputRedirectUrl))) {
            throw new Error(`AuthCodeRedirectHandler cannot handle [${inputRedirectUrl}]: it is missing one of [code, state].`);
        }
        const url = new url_1.URL(inputRedirectUrl);
        const oauthState = url.searchParams.get("state");
        url.searchParams.delete("code");
        url.searchParams.delete("state");
        const sessionId = await solid_client_authn_core_1.getSessionIdFromOauthState(this.storageUtility, oauthState);
        if (sessionId === undefined) {
            throw new Error(`No stored session is associated with the state [${oauthState}]`);
        }
        const oidcContext = await solid_client_authn_core_1.loadOidcContextFromStorage(sessionId, this.storageUtility, this.issuerConfigFetcher);
        const issuer = new openid_client_1.Issuer(IssuerConfigFetcher_1.configToIssuerMetadata(oidcContext.issuerConfig));
        const clientInfo = await this.clientRegistrar.getClient({ sessionId }, oidcContext.issuerConfig);
        const client = new issuer.Client({
            client_id: clientInfo.clientId,
            client_secret: clientInfo.clientSecret,
        });
        const params = client.callbackParams(inputRedirectUrl);
        let dpopKey;
        let tokenSet;
        let authFetch;
        if (oidcContext.dpop) {
            dpopKey = await jose_1.JWK.generate("EC", "P-256");
            tokenSet = await client.callback(url.href, params, { code_verifier: oidcContext.codeVerifier, state: oauthState }, { DPoP: dpopKey.toJWK(true) });
        }
        else {
            tokenSet = await client.callback(url.href, params, {
                code_verifier: oidcContext.codeVerifier,
                state: oauthState,
            });
        }
        if (tokenSet.access_token === undefined ||
            tokenSet.id_token === undefined) {
            throw new Error(`The Identity Provider [${issuer.metadata.issuer}] did not return the expected tokens: missing at least one of 'access_token', 'id_token.`);
        }
        let refreshOptions;
        if (tokenSet.refresh_token !== undefined) {
            refreshOptions = {
                refreshToken: tokenSet.refresh_token,
                sessionId,
                tokenRefresher: this.tokenRefresher,
            };
        }
        if (oidcContext.dpop) {
            authFetch = await fetchFactory_1.buildDpopFetch(tokenSet.access_token, dpopKey, refreshOptions);
        }
        else {
            authFetch = fetchFactory_1.buildBearerFetch(tokenSet.access_token, refreshOptions);
        }
        const webid = await getWebidFromTokenPayload(tokenSet.claims());
        await solid_client_authn_core_1.saveSessionInfoToStorage(this.storageUtility, sessionId, tokenSet.id_token, webid, "true", tokenSet.refresh_token);
        const sessionInfo = await this.sessionInfoManager.get(sessionId);
        if (!sessionInfo) {
            throw new Error(`Could not find any session information associated with SessionID [${sessionId}] in our storage.`);
        }
        return Object.assign(sessionInfo, {
            fetch: authFetch,
        });
    }
};
AuthCodeRedirectHandler = __decorate([
    tsyringe_1.injectable(),
    __param(0, tsyringe_1.inject("storageUtility")),
    __param(1, tsyringe_1.inject("sessionInfoManager")),
    __param(2, tsyringe_1.inject("issuerConfigFetcher")),
    __param(3, tsyringe_1.inject("clientRegistrar")),
    __param(4, tsyringe_1.inject("tokenRefresher")),
    __metadata("design:paramtypes", [Object, Object, Object, Object, Object])
], AuthCodeRedirectHandler);
exports.AuthCodeRedirectHandler = AuthCodeRedirectHandler;
//# sourceMappingURL=AuthCodeRedirectHandler.js.map