"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createServerlessPod = createServerlessPod;
exports.getContentType = getContentType;
exports.isAuxResource = isAuxResource;
exports.getAuxResources = getAuxResources;
exports.generateRandomSlug = generateRandomSlug;
exports.linksExt = exports.linkExt = void 0;

var _path = _interopRequireDefault(require("path"));

var _mimeTypes = require("mime-types");

var _uuid = require("uuid");

var pod = _interopRequireWildcard(require("./createServerlessPod.js"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const linkExt = ['.acl', '.meta'];
exports.linkExt = linkExt;
const linksExt = linkExt.concat('.meta.acl');
exports.linksExt = linksExt;

function url2Path(url) {}

async function createServerlessPod(base) {
  console.log(`Creating pod at <${base}>`);
  base = base.replace(/\/$/, '');
  base = base.replace(/^[^:]*:\/\//, '');
  await this.perform('FULL_PUT', base + "/.acl", pod.acl_content);
  await this.perform('FULL_PUT', base + "/profile/card", pod.profile_content);
  await this.perform('FULL_PUT', base + "/settings/prefs.ttl", pod.prefs_content);
  await this.perform('FULL_PUT', base + "/settings/privateTypeIndex.ttl", pod.private_content);
  await this.perform('FULL_PUT', base + "/settings/publicTypeIndex.ttl", pod.public_content);
  await this.perform('FULL_PUT', base + "/private/.meta", "");
  await this.perform('FULL_PUT', base + "/.well-known/.meta", "");
  await this.perform('FULL_PUT', base + "/public/.meta", "");
  await this.perform('FULL_PUT', base + "/inbox/.meta", "");
}

function getContentType(ext, type) {
  if (!ext || ext === '.ttl' || ext === '.acl' || ext === '.meta' || type === "Container") {
    return 'text/turtle';
  } else {
    let ctype = (0, _mimeTypes.contentType)(ext);
    return ctype ? ctype : 'text/turtle';
  }
}

function isAuxResource(o) {
  return linkExt.find(ext => this.getExtension(o) === ext);
}

async function getAuxResources(pathname) {
  let linksExists = linksExt.filter(async ext => await this.perform('ITEM_EXISTS', pathname + ext));
  const links = linksExists.map(ext => pathname + ext);
  return links || [];
}

async function generateRandomSlug(pathname, slug = (0, _uuid.v1)()) {
  let requestUrl = this.mungePath(pathname, slug);
  if (this.item.isContainer && !this.request.url.endsWith(this.pathSep)) requestUrl = requestUrl + this.pathSep;

  if (await this.perform('ITEM_EXISTS', requestUrl)) {
    slug = `${(0, _uuid.v1)()}-${slug}`;
  }

  return this.mungePath(pathname, slug);
}