"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Session = exports.defaultStorage = void 0;
const events_1 = require("events");
const solid_client_authn_core_1 = require("@inrupt/solid-client-authn-core");
const uuid_1 = require("uuid");
const cross_fetch_1 = require("cross-fetch");
const dependencies_1 = require("./dependencies");
exports.defaultStorage = new solid_client_authn_core_1.InMemoryStorage();
class Session extends events_1.EventEmitter {
    constructor(sessionOptions = {}, sessionId) {
        super();
        this.tokenRequestInProgress = false;
        this.login = async (options) => {
            const loginInfo = await this.clientAuthentication.login(this.info.sessionId, {
                ...options,
            });
            if (loginInfo !== undefined) {
                this.info.isLoggedIn = loginInfo.isLoggedIn;
                this.info.sessionId = loginInfo.sessionId;
                this.info.webId = loginInfo.webId;
            }
        };
        this.fetch = async (url, init) => {
            if (!this.info.isLoggedIn) {
                return cross_fetch_1.fetch(url, init);
            }
            return this.clientAuthentication.fetch(url, init);
        };
        this.logout = async () => {
            await this.clientAuthentication.logout(this.info.sessionId);
            this.info.isLoggedIn = false;
            this.emit("logout");
        };
        this.handleIncomingRedirect = async (url) => {
            let sessionInfo;
            if (this.info.isLoggedIn) {
                sessionInfo = this.info;
            }
            else if (this.tokenRequestInProgress) {
            }
            else {
                try {
                    this.tokenRequestInProgress = true;
                    sessionInfo = await this.clientAuthentication.handleIncomingRedirect(url);
                    if (sessionInfo) {
                        this.info.isLoggedIn = sessionInfo.isLoggedIn;
                        this.info.webId = sessionInfo.webId;
                        this.info.sessionId = sessionInfo.sessionId;
                        if (sessionInfo.isLoggedIn) {
                            this.emit("login");
                        }
                    }
                }
                finally {
                    this.tokenRequestInProgress = false;
                }
            }
            return sessionInfo;
        };
        if (sessionOptions.clientAuthentication) {
            this.clientAuthentication = sessionOptions.clientAuthentication;
        }
        else if (sessionOptions.storage) {
            this.clientAuthentication = dependencies_1.getClientAuthenticationWithDependencies({
                secureStorage: sessionOptions.storage,
                insecureStorage: sessionOptions.storage,
            });
        }
        else if (sessionOptions.secureStorage && sessionOptions.insecureStorage) {
            this.clientAuthentication = dependencies_1.getClientAuthenticationWithDependencies({
                secureStorage: sessionOptions.secureStorage,
                insecureStorage: sessionOptions.insecureStorage,
            });
        }
        else {
            this.clientAuthentication = dependencies_1.getClientAuthenticationWithDependencies({
                secureStorage: exports.defaultStorage,
                insecureStorage: exports.defaultStorage,
            });
        }
        if (sessionOptions.sessionInfo) {
            this.info = {
                sessionId: sessionOptions.sessionInfo.sessionId,
                isLoggedIn: false,
                webId: sessionOptions.sessionInfo.webId,
            };
        }
        else {
            this.info = {
                sessionId: sessionId !== null && sessionId !== void 0 ? sessionId : uuid_1.v4(),
                isLoggedIn: false,
            };
        }
    }
    onLogin(callback) {
        this.on("login", callback);
    }
    onLogout(callback) {
        this.on("logout", callback);
    }
}
exports.Session = Session;
//# sourceMappingURL=Session.js.map