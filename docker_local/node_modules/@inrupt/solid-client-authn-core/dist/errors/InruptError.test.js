"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const globals_1 = require("@jest/globals");
const cross_fetch_1 = require("cross-fetch");
const vocab_inrupt_common_1 = require("@inrupt/vocab-inrupt-common");
const n3_1 = require("n3");
const solid_common_vocab_1 = require("@inrupt/solid-common-vocab");
const InruptError_1 = __importDefault(require("./InruptError"));
globals_1.describe("InruptError", () => {
    globals_1.describe("simple error message strings", () => {
        globals_1.it("treats a message as a simple message", () => {
            const message = "Normal error string...";
            const error = new InruptError_1.default(message);
            globals_1.expect(error.name).toEqual("Error");
            globals_1.expect(error.toString()).toContain(message);
        });
        globals_1.it("treats a message as a simple message having params", () => {
            const error = new InruptError_1.default("Normal [{{1}}] error string with [{{0}}]...", ["one", "two"]);
            globals_1.expect(error.name).toEqual("Error");
            globals_1.expect(error.toString()).toContain("Error: Normal [two] error string with [one]...");
        });
        globals_1.it("fails if message has incorrect number of params", () => {
            globals_1.expect(() => new InruptError_1.default("Normal [{{1}}] error string with [{{0}}]...", [
                "one",
                "two",
                "three",
            ])).toThrow("requires [2] params and we received [3]");
        });
    });
    globals_1.describe("errors that include HTTP response meta-data", () => {
        globals_1.it("extracts HTTP Response details, but doesn't append details to message", () => {
            const failedResponse = new cross_fetch_1.Response(undefined, {
                status: 404,
            });
            const message = "Normal error string...";
            const error = new InruptError_1.default(message).httpResponse(failedResponse, false);
            globals_1.expect(error.name).toEqual("Error");
            globals_1.expect(error.hasHttpResponse()).toEqual(true);
            globals_1.expect(error.getHttpStatusCode()).toEqual(404);
            globals_1.expect(error.getHttpStatusText()).toEqual("Not Found");
            globals_1.expect(error.toString()).toContain(message);
            globals_1.expect(error.toString()).not.toContain("404");
        });
        globals_1.it("extracts HTTP Response details, and appends details to message", () => {
            const failedResponse = new cross_fetch_1.Response(undefined, {
                status: 404,
            });
            const message = "Normal error string...";
            const error = new InruptError_1.default(message).httpResponse(failedResponse);
            globals_1.expect(error.name).toEqual("Error");
            globals_1.expect(error.hasHttpResponse()).toEqual(true);
            globals_1.expect(error.getHttpStatusCode()).toEqual(404);
            globals_1.expect(error.getHttpStatusText()).toEqual("Not Found");
            globals_1.expect(error.toString()).toContain(message);
            globals_1.expect(error.toString()).toContain("404");
        });
        globals_1.it("throws if no HTTP response", () => {
            const message = "Normal error string...";
            const error = new InruptError_1.default(message);
            globals_1.expect(error.hasHttpResponse()).toBeFalsy();
            globals_1.expect(() => error.getHttpStatusCode()).toThrow("can't get its HTTP Status Code.");
            globals_1.expect(() => error.getHttpStatusText()).toThrow("can't get its HTTP Status Text!");
        });
        globals_1.it("get HTTP response returns undefined if no HTTP response", () => {
            const message = "Normal error string...";
            const error = new InruptError_1.default(message);
            globals_1.expect(error.getHttpResponse()).toBeUndefined();
        });
        globals_1.it("gets the specified HTTP response if it was provided", () => {
            const failedResponse = new cross_fetch_1.Response(undefined, {
                status: 404,
            });
            const message = "Normal error string...";
            const error = new InruptError_1.default(message).httpResponse(failedResponse);
            globals_1.expect(error.getHttpResponse()).toEqual(failedResponse);
        });
    });
    globals_1.describe("errors coming from RDF vocabs", () => {
        globals_1.describe("from remote (non-locally imported) vocabs", () => {
            globals_1.it("pulls message string from remote RDF vocab", () => {
                const errorIri = new n3_1.NamedNode("https://example.com/vocab#errTest1");
                const error = new InruptError_1.default(errorIri);
                globals_1.expect(error.name).toEqual("Error");
                globals_1.expect(error.toString()).toContain(errorIri.value);
                globals_1.expect(error.toString()).toContain("message looked up at");
            });
            globals_1.it("pulls message string from remote RDF vocab, having params", () => {
                const errorIri = new n3_1.NamedNode("https://example.com/vocab#errTest1");
                const params = ["one", "two"];
                const error = new InruptError_1.default(errorIri, params);
                globals_1.expect(error.name).toEqual("Error");
                globals_1.expect(error.toString()).toContain(params[0]);
                globals_1.expect(error.toString()).toContain(params[1]);
                globals_1.expect(error.toString()).toContain(errorIri.value);
                globals_1.expect(error.toString()).toContain("message looked up at");
            });
        });
        globals_1.describe("from locally imported vocabs", () => {
            globals_1.it("reports failure to find message value on RDF vocab term with no message", () => {
                const errorIri = vocab_inrupt_common_1.INRUPT_TEST.somePredicate;
                const error = new InruptError_1.default(errorIri);
                globals_1.expect(error.name).toEqual("Error");
                globals_1.expect(error.toString()).toContain(errorIri.value);
                globals_1.expect(error.toString()).toContain("found no message value");
            });
            globals_1.it("pulls parameterized message string from local RDF vocab", () => {
                const vocabError = vocab_inrupt_common_1.UI_COMMON.errFileUpload_exceededSizeLimit;
                const params = ["one", "two", "three"];
                const error = new InruptError_1.default(vocabError, params);
                globals_1.expect(error.name).toEqual("Error");
                globals_1.expect(error.hasHttpResponse()).toBeFalsy();
                globals_1.expect(error.toString()).toContain(params[0]);
                globals_1.expect(error.toString()).toContain(params[1]);
                globals_1.expect(error.toString()).toContain(params[2]);
                globals_1.expect(error.toString()).toContain(vocabError.value);
                globals_1.expect(error.toString()).toContain("has size");
                globals_1.expect(error.toString()).toContain("that exceeds the allowable limit");
            });
            globals_1.it("pulls localized parameterized message string from local RDF vocab", () => {
                const errorIri = vocab_inrupt_common_1.UI_COMMON.errFileUpload_exceededSizeLimit;
                const params = ["one", "two", "three"];
                const locale = solid_common_vocab_1.getLocalStore().getItem(solid_common_vocab_1.CONTEXT_KEY_LOCALE);
                try {
                    solid_common_vocab_1.getLocalStore().setItem(solid_common_vocab_1.CONTEXT_KEY_LOCALE, "es");
                    const error = new InruptError_1.default(errorIri, params);
                    globals_1.expect(error.name).toEqual("Error");
                    globals_1.expect(error.hasHttpResponse()).toBeFalsy();
                    globals_1.expect(error.toString()).toContain(params[0]);
                    globals_1.expect(error.toString()).toContain(params[1]);
                    globals_1.expect(error.toString()).toContain(params[2]);
                    globals_1.expect(error.toString()).toContain(errorIri.value);
                    globals_1.expect(error.toString()).toContain("del archivo");
                    globals_1.expect(error.toString()).toContain("excede el límite permitido");
                }
                finally {
                    solid_common_vocab_1.getLocalStore().setItem(solid_common_vocab_1.CONTEXT_KEY_LOCALE, locale);
                }
            });
            globals_1.it("pulls localized parameterized message string from local RDF vocab with HTTP response and no IRI", () => {
                const errorIri = vocab_inrupt_common_1.UI_COMMON.errFileUpload_exceededSizeLimit;
                const params = ["one", "two", "three"];
                const locale = solid_common_vocab_1.getLocalStore().getItem(solid_common_vocab_1.CONTEXT_KEY_LOCALE);
                try {
                    solid_common_vocab_1.getLocalStore().setItem(solid_common_vocab_1.CONTEXT_KEY_LOCALE, "fr");
                    const failedResponse = new cross_fetch_1.Response(undefined, {
                        status: 404,
                    });
                    const error = new InruptError_1.default(errorIri, params, false).httpResponse(failedResponse, true);
                    globals_1.expect(error.name).toEqual("Error");
                    globals_1.expect(error.hasHttpResponse()).toEqual(true);
                    globals_1.expect(error.getHttpStatusCode()).toEqual(404);
                    globals_1.expect(error.getHttpStatusText()).toEqual("Not Found");
                    globals_1.expect(error.toString()).toContain(params[0]);
                    globals_1.expect(error.toString()).toContain(params[1]);
                    globals_1.expect(error.toString()).toContain(params[2]);
                    globals_1.expect(error.toString()).not.toContain(errorIri.value);
                    globals_1.expect(error.toString()).toContain("La taille du fichier");
                    globals_1.expect(error.toString()).toContain("dépasse la limite autorisée");
                }
                finally {
                    solid_common_vocab_1.getLocalStore().setItem(solid_common_vocab_1.CONTEXT_KEY_LOCALE, locale);
                }
            });
        });
    });
});
//# sourceMappingURL=InruptError.test.js.map