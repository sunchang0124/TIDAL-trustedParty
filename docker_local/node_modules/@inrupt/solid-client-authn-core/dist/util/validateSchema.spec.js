"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const validateSchema_1 = __importDefault(require("./validateSchema"));
describe("validateSchema", () => {
    it("should return true if the given data matches the given schema", () => {
        const schema = {
            type: "object",
            properties: {
                foo: { type: "number" },
            },
        };
        expect(() => validateSchema_1.default(schema, { foo: 42 })).not.toThrow();
    });
    it("should not throw an error if the given data matches the given schema", () => {
        const schema = {
            type: "object",
            properties: {
                foo: { type: "number" },
            },
        };
        expect(() => validateSchema_1.default(schema, { foo: 42 })).not.toThrow();
    });
    it("should mark anything as valid when there is no schema to validate against", () => {
        expect(() => validateSchema_1.default({}, {})).not.toThrow();
    });
    it("should return false by default if the given data does not match the given schema", () => {
        const schema = {
            type: "object",
            properties: {
                foo: { type: "number" },
            },
        };
        expect(() => validateSchema_1.default(schema, { foo: "Not a number" })).toThrow();
    });
    it("should throw an error when told to if the given data does not match the given schema", () => {
        const schema = {
            type: "object",
            properties: {
                foo: { type: "number" },
            },
        };
        expect(() => validateSchema_1.default(schema, { foo: "Not a number" })).toThrow("schema is invalid:\n.foo should be number");
    });
    it("should log the failing schema's title if known", () => {
        const schema = {
            title: "Some schema",
            type: "object",
            properties: {
                foo: { type: "number" },
            },
        };
        expect(() => validateSchema_1.default(schema, { foo: "Not a number" })).toThrow("Some schema is invalid:\n.foo should be number");
    });
    describe("with our custom `typeof` keyword", () => {
        it("should properly validate if the given type matches the one mentioned in the schema", () => {
            const schema = {
                type: "object",
                properties: {
                    foo: { typeof: "number" },
                },
            };
            expect(() => validateSchema_1.default(schema, { foo: 42 })).not.toThrow();
        });
        it("should not validate if the given type does not match the one mentioned in the schema", () => {
            const schema = {
                type: "object",
                properties: {
                    foo: { typeof: "number" },
                },
            };
            expect(() => validateSchema_1.default(schema, { foo: "Not a number" })).toThrow();
        });
        it("should properly validate non-JSON types as well", () => {
            const schema = {
                type: "object",
                properties: {
                    foo: { typeof: "function" },
                },
            };
            expect(() => validateSchema_1.default(schema, { foo: () => 1337 })).not.toThrow();
        });
        it("should not validate if the given type does not match a requested non-JSON type", () => {
            const schema = {
                type: "object",
                properties: {
                    foo: { typeof: "function" },
                },
            };
            expect(() => validateSchema_1.default(schema, { foo: 42 })).toThrow();
        });
        it("should not validate if the given non-JSON type does not match the requested type", () => {
            const schema = {
                type: "object",
                properties: {
                    foo: { typeof: "number" },
                },
            };
            expect(() => validateSchema_1.default(schema, { foo: () => "A function" })).toThrow();
        });
    });
    describe("with our custom `joinedStringOf` keyword", () => {
        it("should properly validate if the checked string consists of the words in the given array", () => {
            const schema = {
                type: "object",
                properties: {
                    foo: {
                        joinedStringOf: [
                            "some",
                            "words",
                            "not",
                            "necessarily",
                            "in",
                            "this",
                            "order",
                        ],
                    },
                },
            };
            expect(() => validateSchema_1.default(schema, {
                foo: "not necessarily some words in this order",
            })).not.toThrow();
        });
        it("should not validate if the checked string includes more than the given words", () => {
            const schema = {
                type: "object",
                properties: {
                    foo: {
                        joinedStringOf: [
                            "some",
                            "words",
                            "not",
                            "necessarily",
                            "in",
                            "this",
                            "order",
                        ],
                    },
                },
            };
            expect(() => validateSchema_1.default(schema, {
                foo: "some words in this order but not necessarily with just those words ",
            })).toThrow();
        });
        it.skip("should not validate if the checked string includes not all the given words", () => {
            const schema = {
                type: "object",
                properties: {
                    foo: {
                        joinedStringOf: [
                            "some",
                            "words",
                            "not",
                            "necessarily",
                            "in",
                            "this",
                            "order",
                        ],
                    },
                },
            };
            expect(validateSchema_1.default(schema, { foo: "some words" })).toThrow();
        });
    });
    describe("applying custom url conversion", () => {
        it("converts urls in a simple object", () => {
            const newObj = validateSchema_1.default({
                type: "object",
                properties: {
                    foo: { type: "string", shouldConvertToUrl: true },
                },
            }, {
                foo: "https://cool.com/nice",
            });
            expect(newObj.foo.startsWith("https://cool.com")).toBeTruthy();
        });
        it("converts urls in a complex object", () => {
            const newObj = validateSchema_1.default({
                type: "object",
                properties: {
                    arr: {
                        type: "array",
                        items: {
                            type: "object",
                            properties: {
                                url: { type: "string", shouldConvertToUrl: true },
                            },
                        },
                    },
                },
            }, {
                arr: [
                    { url: "https://cool.com/nice" },
                    { url: "https://lame.com/mean" },
                ],
            });
            expect(newObj.arr[0].url.startsWith("https://cool.com")).toBeTruthy();
            expect(newObj.arr[1].url.startsWith("https://lame.com")).toBeTruthy();
        });
        it("is not tripped up by weird schema traversal", () => {
            expect(() => validateSchema_1.default({
                type: "object",
                properties: {
                    arr: {
                        type: "array",
                    },
                    obj: {
                        type: "object",
                    },
                },
            }, {
                arr: [1, "cool"],
                obj: {
                    foo: "foo",
                    bar: "bar",
                },
            })).not.toThrow();
        });
    });
});
//# sourceMappingURL=validateSchema.spec.js.map