"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const AggregateHandler_1 = __importDefault(require("./AggregateHandler"));
describe("AggregateHandler", () => {
    class AggregateMockHandler extends AggregateHandler_1.default {
        constructor(mockHandlers) {
            super(mockHandlers);
        }
    }
    function initMocks(configs) {
        const mockHandlerInfo = configs.map((config) => {
            const canHandleFunction = jest.fn(async (_input) => {
                return new Promise((resolve, _reject) => {
                    setTimeout(() => resolve(config.canHandle), config.executeTime);
                });
            });
            const handleFunction = jest.fn(async (_input) => {
                return new Promise((resolve, _reject) => {
                    setTimeout(() => resolve(config.toReturn), config.executeTime);
                });
            });
            const mock = jest.fn(() => ({
                canHandle: canHandleFunction,
                handle: handleFunction,
            }));
            return {
                canHandleFunction,
                handleFunction,
                mock,
            };
        });
        const aggregateMockHandler = new AggregateMockHandler(mockHandlerInfo.map((info) => info.mock()));
        return {
            mockHandlerInfo,
            aggregateMockHandler,
        };
    }
    describe("canHandle", () => {
        it("should return correct handler", async () => {
            const mocks = initMocks([
                { canHandle: true, executeTime: 0, toReturn: "" },
                { canHandle: false, executeTime: 0, toReturn: "" },
            ]);
            const result = await mocks.aggregateMockHandler.canHandle("something");
            expect(result).toBe(true);
        });
        it("should error if there is no correct handler", async () => {
            const mocks = initMocks([
                { canHandle: false, executeTime: 0, toReturn: "" },
                { canHandle: false, executeTime: 0, toReturn: "" },
            ]);
            expect(await mocks.aggregateMockHandler.canHandle("something")).toBe(false);
        });
    });
    describe("handle", () => {
        it("should execute the handler", async () => {
            const mocks = initMocks([
                { canHandle: true, executeTime: 0, toReturn: "allGood" },
            ]);
            const result = await mocks.aggregateMockHandler.handle("something");
            expect(result).toBe("allGood");
        });
        it.skip("should run the correct handler even when it is preceded by the incorrect handler", () => {
        });
        it.skip("should run the first correct handler even when succeeded by a handler that takes a shorter time to execute", () => {
        });
        it("should error when there is no correct handler", async () => {
            const mocks = initMocks([
                { canHandle: false, executeTime: 0, toReturn: "" },
                { canHandle: false, executeTime: 0, toReturn: "" },
            ]);
            await expect(() => mocks.aggregateMockHandler.handle("something")).rejects.toThrow();
        });
        it("should error when there is no correct handler, and handle invalid JSON", async () => {
            const mocks = initMocks([
                { canHandle: false, executeTime: 0, toReturn: "" },
                { canHandle: false, executeTime: 0, toReturn: "" },
            ]);
            const obj = {
                prop: {},
            };
            obj.prop = obj;
            await expect(() => mocks.aggregateMockHandler.handle(obj)).rejects.toThrow();
        });
    });
});
//# sourceMappingURL=AggregateHandler.spec.js.map