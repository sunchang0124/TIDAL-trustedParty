"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const IssuerConfig_1 = require("../login/oidc/__mocks__/IssuerConfig");
const IssuerConfigFetcher_1 = require("../login/oidc/__mocks__/IssuerConfigFetcher");
const StorageUtility_1 = __importStar(require("./StorageUtility"));
const StorageUtility_2 = require("./__mocks__/StorageUtility");
describe("StorageUtility", () => {
    const defaultMocks = {
        secureStorage: StorageUtility_2.mockStorage({}),
        insecureStorage: StorageUtility_2.mockStorage({}),
    };
    const key = "the key";
    const value = "the value";
    const userId = "animals";
    function getStorageUtility(mocks = defaultMocks) {
        var _a, _b;
        return new StorageUtility_1.default((_a = mocks.secureStorage) !== null && _a !== void 0 ? _a : defaultMocks.secureStorage, (_b = mocks.insecureStorage) !== null && _b !== void 0 ? _b : defaultMocks.insecureStorage);
    }
    describe("get", () => {
        it("gets an item from storage", async () => {
            const storageUtility = getStorageUtility({
                insecureStorage: StorageUtility_2.mockStorage({}),
            });
            await storageUtility.set(key, value);
            const result = await storageUtility.get(key);
            expect(result).toBe(value);
        });
        it("gets an item from (secure) storage", async () => {
            const storageUtility = getStorageUtility({
                secureStorage: StorageUtility_2.mockStorage({}),
            });
            await storageUtility.set(key, value, { secure: true });
            const result = await storageUtility.get(key, { secure: true });
            expect(result).toBe(value);
        });
        it("returns undefined if the item is not in storage", async () => {
            const storageUtility = getStorageUtility({
                insecureStorage: StorageUtility_2.mockStorage({}),
            });
            const retrievedValue = await storageUtility.get("key");
            expect(retrievedValue).toBeUndefined();
        });
        it("throws an error if the item is not in storage and errorOnNull is true", async () => {
            const storageMock = defaultMocks.insecureStorage;
            const storageUtility = getStorageUtility({
                insecureStorage: storageMock,
            });
            await expect(storageUtility.get("key", { errorIfNull: true })).rejects.toThrow("[key] is not stored");
        });
    });
    describe("set", () => {
        it("sets an item in storage", async () => {
            const storageUtility = getStorageUtility({
                insecureStorage: StorageUtility_2.mockStorage({}),
            });
            await storageUtility.set(key, value);
            await expect(storageUtility.get(key)).resolves.toEqual(value);
        });
    });
    describe("delete", () => {
        it("deletes an item", async () => {
            const storageUtility = getStorageUtility({
                insecureStorage: StorageUtility_2.mockStorage({}),
            });
            await expect(storageUtility.get(key)).resolves.toBeUndefined();
            await storageUtility.set(key, value);
            await expect(storageUtility.get(key)).resolves.toEqual(value);
            await storageUtility.delete(key);
            await expect(storageUtility.get(key)).resolves.toBeUndefined();
        });
        it("deletes an item (from secure storage)", async () => {
            const storageUtility = getStorageUtility({
                insecureStorage: StorageUtility_2.mockStorage({}),
            });
            await expect(storageUtility.get(key, { secure: true })).resolves.toBeUndefined();
            await storageUtility.set(key, value, { secure: true });
            await expect(storageUtility.get(key, { secure: true })).resolves.toEqual(value);
            await storageUtility.delete(key, { secure: true });
            await expect(storageUtility.get(key, { secure: true })).resolves.toBeUndefined();
        });
    });
    describe("getForUser", () => {
        it("throws if data stored is invalid JSON", async () => {
            const mockedStorageUtility = StorageUtility_2.mockStorage({});
            mockedStorageUtility.get = jest
                .fn()
                .mockReturnValue("This response deliberately cannot be parsed as JSON!");
            const storageUtility = getStorageUtility({
                insecureStorage: mockedStorageUtility,
                secureStorage: mockedStorageUtility,
            });
            await expect(storageUtility.getForUser("irrelevant for this test", "Doesn't matter")).rejects.toThrow("cannot be parsed as JSON!");
            await expect(storageUtility.getForUser("irrelevant for this test", "Doesn't matter", { secure: true })).rejects.toThrow("cannot be parsed as JSON!");
        });
        it("gets an item from storage for a user", async () => {
            const storageUtility = getStorageUtility({
                insecureStorage: StorageUtility_2.mockStorage({}),
            });
            const userData = {
                jackie: "The Cat",
                sledge: "The Dog",
            };
            await storageUtility.setForUser(userId, userData);
            const retrievedValue = await storageUtility.getForUser(userId, "jackie");
            expect(retrievedValue).toBe("The Cat");
        });
        it("gets an item from (secure) storage for a user", async () => {
            const storageUtility = getStorageUtility({
                secureStorage: StorageUtility_2.mockStorage({}),
            });
            const userData = {
                jackie: "The Cat",
                sledge: "The Dog",
            };
            await storageUtility.setForUser(userId, userData, {
                secure: true,
            });
            const retrievedValue = await storageUtility.getForUser(userId, "jackie", {
                secure: true,
            });
            expect(retrievedValue).toBe("The Cat");
        });
        it("returns undefined if no item is in storage", async () => {
            const storageUtility = getStorageUtility({
                insecureStorage: StorageUtility_2.mockStorage({}),
            });
            const retrievedValue = await storageUtility.getForUser(userId, "jackie");
            expect(retrievedValue).toBeUndefined();
        });
        it("returns null if the item in storage is corrupted", async () => {
            const storageUtility = getStorageUtility({
                insecureStorage: StorageUtility_2.mockStorage({}),
            });
            await storageUtility.setForUser(userId, {
                cool: "bleep bloop not parsable",
            });
            const retrievedValue = await storageUtility.getForUser(userId, "jackie");
            expect(retrievedValue).toBeUndefined();
        });
        it("throws an error if the item is not in storage and errorOnNull is true", async () => {
            const storageUtility = getStorageUtility({
                insecureStorage: StorageUtility_2.mockStorage({}),
            });
            await expect(storageUtility.getForUser(userId, "jackie", { errorIfNull: true })).rejects.toThrow(`Field [jackie] for user [${userId}] is not stored`);
        });
    });
    describe("setForUser", () => {
        it("sets a value for a user", async () => {
            const storageUtility = getStorageUtility({
                insecureStorage: StorageUtility_2.mockStorage({}),
            });
            await storageUtility.setForUser(userId, {
                jackie: "The Pretty Kitty",
            });
            const retrievedValue = await storageUtility.getForUser(userId, "jackie");
            expect(retrievedValue).toBe("The Pretty Kitty");
        });
        it("sets a value for a user if the original data was corrupted", async () => {
            const storageMock = defaultMocks.insecureStorage;
            await storageMock.set(`solidClientAuthenticationUser:${userId}`, 'cool: "bleep bloop not parsable"');
            const storageUtility = getStorageUtility({
                insecureStorage: storageMock,
            });
            await storageUtility.setForUser(userId, {
                jackie: "The Pretty Kitty",
            });
            const retrievedValue = await storageUtility.getForUser(userId, "jackie");
            expect(retrievedValue).toBe("The Pretty Kitty");
        });
    });
    describe("deleteForUser", () => {
        it("deletes a value for a user from unsecure storage", async () => {
            const userData = {
                jackie: "The Cat",
                sledge: "The Dog",
            };
            const storageUtility = getStorageUtility({
                insecureStorage: StorageUtility_2.mockStorage({}),
            });
            await storageUtility.setForUser(userId, userData);
            await storageUtility.deleteForUser(userId, "jackie");
            await expect(storageUtility.getForUser(userId, "jackie")).resolves.toBeUndefined();
            await expect(storageUtility.getForUser(userId, "sledge")).resolves.toEqual("The Dog");
        });
        it("deletes a value for a user from secure storage", async () => {
            const storageUtility = getStorageUtility({
                secureStorage: StorageUtility_2.mockStorage({
                    "solidClientAuthenticationUser:someUser": {
                        jackie: "The Cat",
                        sledge: "The Dog",
                    },
                }),
            });
            await storageUtility.deleteForUser("someUser", "jackie", {
                secure: true,
            });
            await expect(storageUtility.getForUser("someUser", "jackie", { secure: true })).resolves.toBeUndefined();
            await expect(storageUtility.getForUser("someUser", "sledge", { secure: true })).resolves.toEqual("The Dog");
        });
    });
    describe("deleteAllUserData", () => {
        it("deletes all data for a particular user", async () => {
            const storageUtility = getStorageUtility({
                insecureStorage: StorageUtility_2.mockStorage({}),
            });
            const userData = {
                jackie: "The Cat",
                sledge: "The Dog",
            };
            await storageUtility.setForUser(userId, userData);
            await expect(storageUtility.getForUser(userId, "jackie")).resolves.toEqual("The Cat");
            await storageUtility.deleteAllUserData(userId);
            await expect(storageUtility.getForUser(userId, "jackie")).resolves.toBeUndefined();
        });
        it("deletes all data for a particular user (from secure storage)", async () => {
            const storageUtility = getStorageUtility({
                secureStorage: StorageUtility_2.mockStorage({}),
            });
            const userData = {
                jackie: "The Cat",
                sledge: "The Dog",
            };
            await storageUtility.setForUser(userId, userData, { secure: true });
            await expect(storageUtility.getForUser(userId, "jackie", { secure: true })).resolves.toEqual("The Cat");
            await storageUtility.deleteAllUserData(userId, { secure: true });
            await expect(storageUtility.getForUser(userId, "jackie", { secure: true })).resolves.toBeUndefined();
        });
    });
    describe("storeResourceServerSessionInfo", () => {
        it("stores session information for a new WebID", async () => {
            var _a;
            const storageUtility = getStorageUtility({
                insecureStorage: StorageUtility_2.mockStorage({}),
            });
            await storageUtility.storeResourceServerSessionInfo("https://some.pod/profile#me", "https://some-resource.provider/", 1610026667);
            expect(JSON.parse((_a = (await storageUtility.get("tmp-resource-server-session-info"))) !== null && _a !== void 0 ? _a : "{}")).toEqual({
                webId: "https://some.pod/profile#me",
                sessions: {
                    "https://some-resource.provider/": {
                        expiration: 1610026667,
                    },
                },
            });
        });
        it("adds a new resource server to a WebID that is already registered", async () => {
            const storageUtility = getStorageUtility({
                insecureStorage: StorageUtility_2.mockStorage({
                    "tmp-resource-server-session-info": JSON.stringify({
                        webId: "https://some.pod/profile#me",
                        sessions: {
                            "https://some-other-resource.provider/": {
                                expiration: 1610026667,
                            },
                        },
                    }),
                }),
            });
            await storageUtility.storeResourceServerSessionInfo("https://some.pod/profile#me", "https://some-resource.provider/", 1610026667);
            await expect(storageUtility.get("tmp-resource-server-session-info")).resolves.toEqual(JSON.stringify({
                webId: "https://some.pod/profile#me",
                sessions: {
                    "https://some-other-resource.provider/": {
                        expiration: 1610026667,
                    },
                    "https://some-resource.provider/": {
                        expiration: 1610026667,
                    },
                },
            }));
        });
        it("overwrites existing sessions when storing a session for a new WebID", async () => {
            const storageUtility = getStorageUtility({
                insecureStorage: StorageUtility_2.mockStorage({
                    "tmp-resource-server-session-info": JSON.stringify({
                        webId: "https://some-other.pod/profile#me",
                        sessions: {
                            "https://some-other-resource.provider/": {
                                expiration: 1610026667,
                            },
                        },
                    }),
                }),
            });
            await storageUtility.storeResourceServerSessionInfo("https://some.pod/profile#me", "https://some-resource.provider/", 1610026667);
            await expect(storageUtility.get("tmp-resource-server-session-info")).resolves.toEqual(JSON.stringify({
                webId: "https://some.pod/profile#me",
                sessions: {
                    "https://some-resource.provider/": {
                        expiration: 1610026667,
                    },
                },
            }));
        });
    });
    describe("clearResourceServerSessionInfo", () => {
        it("doesn't not fail if the WebID does not exist", async () => {
            const storageUtility = getStorageUtility({
                insecureStorage: StorageUtility_2.mockStorage({}),
            });
            await storageUtility.clearResourceServerSessionInfo("https://some-resource.provider/");
            await expect(storageUtility.get("tmp-resource-server-session-info")).resolves.toBeUndefined();
        });
        it("clears the session info object if no session is active", async () => {
            const storageUtility = getStorageUtility({
                insecureStorage: StorageUtility_2.mockStorage({
                    "tmp-resource-server-session-info": JSON.stringify({
                        webId: "https://some.pod/profile#me",
                        sessions: {
                            "https://some-resource.provider/": {
                                expiration: 1610026667,
                            },
                        },
                    }),
                }),
            });
            await storageUtility.clearResourceServerSessionInfo("https://some-resource.provider/");
            await expect(storageUtility.get("tmp-resource-server-session-info")).resolves.toEqual(JSON.stringify({}));
        });
        it("removes the given resource server session info", async () => {
            const storageUtility = getStorageUtility({
                insecureStorage: StorageUtility_2.mockStorage({
                    "tmp-resource-server-session-info": JSON.stringify({
                        webId: "https://some.pod/profile#me",
                        sessions: {
                            "https://some-resource.provider/": {
                                expiration: 1610026667,
                            },
                        },
                    }),
                }),
            });
            await storageUtility.clearResourceServerSessionInfo("https://some-other-resource.provider/");
            await expect(storageUtility.get("tmp-resource-server-session-info")).resolves.toEqual(JSON.stringify({
                webId: "https://some.pod/profile#me",
                sessions: {
                    "https://some-resource.provider/": {
                        expiration: 1610026667,
                    },
                },
            }));
        });
    });
    describe("safeGet", () => {
        it("should correctly retrieve valid data from the given storage", async () => {
            const storageUtility = getStorageUtility({
                insecureStorage: StorageUtility_2.mockStorage({}),
            });
            const jsonData = '   {   "jsonKey":   "some json value"   }';
            await storageUtility.set(key, jsonData);
            const result = await storageUtility.safeGet(key);
            expect(result).toEqual({ jsonKey: "some json value" });
        });
        it("should return null if data could not be found in the given storage", async () => {
            const storageUtility = getStorageUtility({
                insecureStorage: StorageUtility_2.mockStorage({}),
            });
            const retrieved = await storageUtility.safeGet("arbitrary key");
            expect(retrieved).toBeUndefined();
        });
        it("should validate the data from the storage if passed a schema", async () => {
            const storageUtility = getStorageUtility({
                insecureStorage: StorageUtility_2.mockStorage({}),
            });
            const jsonData = '   {   "jsonKey":   "some json value"   }';
            await storageUtility.set(key, jsonData);
            const schema = {
                type: "object",
                properties: {
                    jsonKey: { type: "string" },
                },
            };
            const result = await storageUtility.safeGet(key, {
                schema,
            });
            expect(result).toEqual({ jsonKey: "some json value" });
        });
        it("should throw in case of schema mismatch", async () => {
            const storageUtility = getStorageUtility({
                insecureStorage: StorageUtility_2.mockStorage({}),
            });
            const jsonData = JSON.stringify({ jsonKey: "some json value" });
            await storageUtility.set(key, jsonData);
            const schema = {
                type: "object",
                properties: {
                    jsonKey: { type: "boolean" },
                },
            };
            const result = storageUtility.safeGet(key, {
                schema,
            });
            await expect(result).rejects.toThrow("does not match expected schema");
        });
        it("should throw in case of schema mismatch for user data", async () => {
            const storageUtility = getStorageUtility({
                insecureStorage: StorageUtility_2.mockStorage({
                    "solidClientAuthenticationUser:someUser": {
                        jsonKey: "some json value",
                    },
                }),
            });
            const schema = {
                type: "object",
                properties: {
                    jsonKey: { type: "boolean" },
                },
            };
            const result = storageUtility.safeGet("jsonKey", {
                schema,
                userId: "someUser",
                secure: false,
            });
            await expect(async () => result).rejects.toThrow("does not match expected schema");
        });
        it("gets an item for a user if a user id is passed in", async () => {
            const storageUtility = getStorageUtility({
                insecureStorage: StorageUtility_2.mockStorage({}),
            });
            await storageUtility.setForUser(userId, {
                [key]: '   {   "jsonKey":   "some json value"   }',
            });
            const result = await storageUtility.safeGet(key, { userId });
            expect(result).toEqual({ jsonKey: "some json value" });
        });
    });
});
describe("getSessionIdFromOauthState", () => {
    it("returns undefined if no stored OIDC 'state' matches the current request's OIDC 'state' value", async () => {
        const mockedStorage = StorageUtility_2.mockStorageUtility({});
        await expect(StorageUtility_1.getSessionIdFromOauthState(mockedStorage, "some non-existent 'state' value")).resolves.toBeUndefined();
    });
});
describe("loadOidcContextFromStorage", () => {
    it("throws if no issuer is stored for the user", async () => {
        const mockedStorage = StorageUtility_2.mockStorageUtility({
            "solidClientAuthenticationUser:mySession": {
                codeVerifier: "some code verifier",
                redirectUrl: "https://my.app/redirect",
                dpop: "true",
            },
        });
        await expect(StorageUtility_1.loadOidcContextFromStorage("mySession", mockedStorage, IssuerConfigFetcher_1.mockIssuerConfigFetcher(IssuerConfig_1.mockIssuerConfig()))).rejects.toThrow("Failed to retrieve OIDC context from storage associated with session [mySession]");
    });
    it("throws if no token type is stored for the user", async () => {
        const mockedStorage = StorageUtility_2.mockStorageUtility({
            "solidClientAuthenticationUser:mySession": {
                issuer: "https://my.idp/",
                codeVerifier: "some code verifier",
                redirectUrl: "https://my.app/redirect",
            },
        });
        await expect(StorageUtility_1.loadOidcContextFromStorage("mySession", mockedStorage, IssuerConfigFetcher_1.mockIssuerConfigFetcher(IssuerConfig_1.mockIssuerConfig()))).rejects.toThrow("Failed to retrieve OIDC context from storage associated with session [mySession]");
    });
    it("Returns the value in storage if available", async () => {
        const mockedStorage = StorageUtility_2.mockStorageUtility({
            "solidClientAuthenticationUser:mySession": {
                issuer: "https://my.idp/",
                codeVerifier: "some code verifier",
                redirectUrl: "https://my.app/redirect",
                dpop: "true",
            },
        });
        await expect(StorageUtility_1.loadOidcContextFromStorage("mySession", mockedStorage, IssuerConfigFetcher_1.mockIssuerConfigFetcher(IssuerConfig_1.mockIssuerConfig()))).resolves.toEqual({
            issuerConfig: IssuerConfig_1.mockIssuerConfig(),
            codeVerifier: "some code verifier",
            redirectUrl: "https://my.app/redirect",
            dpop: true,
        });
    });
});
describe("saveSessionInfoToStorage", () => {
    it("saves the refresh token if provided in the given storage", async () => {
        const mockedStorage = StorageUtility_2.mockStorageUtility({});
        await StorageUtility_1.saveSessionInfoToStorage(mockedStorage, "some session", "an ID token", "https://my.webid", "true", "a refresh token", true);
        await expect(mockedStorage.getForUser("some session", "refreshToken", { secure: true })).resolves.toEqual("a refresh token");
    });
    it("saves ID token if provided in the given storage", async () => {
        const mockedStorage = StorageUtility_2.mockStorageUtility({});
        await StorageUtility_1.saveSessionInfoToStorage(mockedStorage, "some session", "an ID token", undefined, undefined, undefined, true);
        await expect(mockedStorage.getForUser("some session", "idToken", { secure: true })).resolves.toEqual("an ID token");
    });
    it("saves the webid if provided in the given storage", async () => {
        const mockedStorage = StorageUtility_2.mockStorageUtility({});
        await StorageUtility_1.saveSessionInfoToStorage(mockedStorage, "some session", undefined, "https://my.webid", undefined, undefined, true);
        await expect(mockedStorage.getForUser("some session", "webId", { secure: true })).resolves.toEqual("https://my.webid");
    });
    it("saves the logged in status if provided in the given storage", async () => {
        const mockedStorage = StorageUtility_2.mockStorageUtility({});
        await StorageUtility_1.saveSessionInfoToStorage(mockedStorage, "some session", undefined, undefined, "true", undefined, true);
        await expect(mockedStorage.getForUser("some session", "isLoggedIn", { secure: true })).resolves.toEqual("true");
    });
});
//# sourceMappingURL=StorageUtility.spec.js.map