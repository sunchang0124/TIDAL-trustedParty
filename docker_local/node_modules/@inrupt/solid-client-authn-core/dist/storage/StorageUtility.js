"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.saveSessionInfoToStorage = exports.loadOidcContextFromStorage = exports.getSessionIdFromOauthState = void 0;
const validateSchema_1 = __importDefault(require("../util/validateSchema"));
const InruptError_1 = __importDefault(require("../errors/InruptError"));
async function getSessionIdFromOauthState(storageUtility, oauthState) {
    return storageUtility.getForUser(oauthState, "sessionId");
}
exports.getSessionIdFromOauthState = getSessionIdFromOauthState;
async function loadOidcContextFromStorage(sessionId, storageUtility, configFetcher) {
    try {
        const [issuerIri, codeVerifier, storedRedirectIri, dpop,] = await Promise.all([
            storageUtility.getForUser(sessionId, "issuer", {
                errorIfNull: true,
            }),
            storageUtility.getForUser(sessionId, "codeVerifier"),
            storageUtility.getForUser(sessionId, "redirectUrl"),
            storageUtility.getForUser(sessionId, "dpop", { errorIfNull: true }),
        ]);
        const issuerConfig = await configFetcher.fetchConfig(issuerIri);
        return {
            codeVerifier,
            redirectUrl: storedRedirectIri,
            issuerConfig,
            dpop: dpop === "true",
        };
    }
    catch (e) {
        throw new Error(`Failed to retrieve OIDC context from storage associated with session [${sessionId}]: ${e.toString()}`);
    }
}
exports.loadOidcContextFromStorage = loadOidcContextFromStorage;
async function saveSessionInfoToStorage(storageUtility, sessionId, idToken, webId, isLoggedIn, refreshToken, secure) {
    if (refreshToken !== undefined) {
        await storageUtility.setForUser(sessionId, { refreshToken }, { secure });
    }
    if (idToken !== undefined) {
        await storageUtility.setForUser(sessionId, { idToken }, { secure });
    }
    if (webId !== undefined) {
        await storageUtility.setForUser(sessionId, { webId }, { secure });
    }
    if (isLoggedIn !== undefined) {
        await storageUtility.setForUser(sessionId, { isLoggedIn }, { secure });
    }
}
exports.saveSessionInfoToStorage = saveSessionInfoToStorage;
class StorageUtility {
    constructor(secureStorage, insecureStorage) {
        this.secureStorage = secureStorage;
        this.insecureStorage = insecureStorage;
        this.RESOURCE_SERVER_SESSION_INFORMATION_KEY = "tmp-resource-server-session-info";
    }
    getKey(userId) {
        return `solidClientAuthenticationUser:${userId}`;
    }
    async getUserData(userId, secure) {
        const stored = await (secure
            ? this.secureStorage
            : this.insecureStorage).get(this.getKey(userId));
        if (stored === undefined) {
            return {};
        }
        try {
            return JSON.parse(stored);
        }
        catch (err) {
            throw new InruptError_1.default(`Data for user [${userId}] in [${secure ? "secure" : "unsecure"}] storage is corrupted - expected valid JSON, but got: ${stored}`);
        }
    }
    async setUserData(userId, data, secure) {
        await (secure ? this.secureStorage : this.insecureStorage).set(this.getKey(userId), JSON.stringify(data));
    }
    async get(key, options) {
        const value = await ((options === null || options === void 0 ? void 0 : options.secure)
            ? this.secureStorage
            : this.insecureStorage).get(key);
        if (value === undefined && (options === null || options === void 0 ? void 0 : options.errorIfNull)) {
            throw new InruptError_1.default(`[${key}] is not stored`);
        }
        return value;
    }
    async set(key, value, options) {
        return ((options === null || options === void 0 ? void 0 : options.secure) ? this.secureStorage : this.insecureStorage).set(key, value);
    }
    async delete(key, options) {
        return ((options === null || options === void 0 ? void 0 : options.secure) ? this.secureStorage : this.insecureStorage).delete(key);
    }
    async getForUser(userId, key, options) {
        const userData = await this.getUserData(userId, options === null || options === void 0 ? void 0 : options.secure);
        let value;
        if (!userData || !userData[key]) {
            value = undefined;
        }
        value = userData[key];
        if (value === undefined && (options === null || options === void 0 ? void 0 : options.errorIfNull)) {
            throw new InruptError_1.default(`Field [${key}] for user [${userId}] is not stored`);
        }
        return value || undefined;
    }
    async setForUser(userId, values, options) {
        let userData;
        try {
            userData = await this.getUserData(userId, options === null || options === void 0 ? void 0 : options.secure);
        }
        catch (_a) {
            userData = {};
        }
        await this.setUserData(userId, { ...userData, ...values }, options === null || options === void 0 ? void 0 : options.secure);
    }
    async deleteForUser(userId, key, options) {
        const userData = await this.getUserData(userId, options === null || options === void 0 ? void 0 : options.secure);
        delete userData[key];
        await this.setUserData(userId, userData, options === null || options === void 0 ? void 0 : options.secure);
    }
    async deleteAllUserData(userId, options) {
        await ((options === null || options === void 0 ? void 0 : options.secure) ? this.secureStorage : this.insecureStorage).delete(this.getKey(userId));
    }
    async storeResourceServerSessionInfo(webId, resourceServerIri, expiration) {
        var _a;
        const sessions = JSON.parse((_a = (await this.insecureStorage.get(this.RESOURCE_SERVER_SESSION_INFORMATION_KEY))) !== null && _a !== void 0 ? _a : "{}");
        if (sessions.webId !== webId) {
            sessions.sessions = {};
        }
        sessions.webId = webId;
        sessions.sessions[resourceServerIri] = {
            expiration,
        };
        await this.insecureStorage.set(this.RESOURCE_SERVER_SESSION_INFORMATION_KEY, JSON.stringify(sessions));
    }
    async clearResourceServerSessionInfo(resourceServerIri) {
        var _a;
        const sessions = JSON.parse((_a = (await this.insecureStorage.get(this.RESOURCE_SERVER_SESSION_INFORMATION_KEY))) !== null && _a !== void 0 ? _a : "{}");
        if (sessions.sessions !== undefined) {
            delete sessions.sessions[resourceServerIri];
            if (Object.keys(sessions.sessions).length === 0) {
                await this.insecureStorage.set(this.RESOURCE_SERVER_SESSION_INFORMATION_KEY, "{}");
            }
            else {
                await this.insecureStorage.set(this.RESOURCE_SERVER_SESSION_INFORMATION_KEY, JSON.stringify(sessions));
            }
        }
    }
    async safeGet(key, options = {}) {
        const locallyStored = options.userId
            ? await this.getForUser(options.userId, key, { secure: options.secure })
            : await this.get(key, { secure: options.secure });
        if (locallyStored) {
            try {
                const parsedObject = JSON.parse(locallyStored);
                if (options.schema) {
                    const val = validateSchema_1.default(options.schema, parsedObject);
                    return val;
                }
                return parsedObject;
            }
            catch (err) {
                let invalidObject;
                if (options.userId) {
                    invalidObject = await this.getForUser(options.userId, key, {
                        secure: options.secure,
                    });
                }
                else {
                    invalidObject = await this.get(key, {
                        secure: options.secure,
                    });
                }
                throw new InruptError_1.default(`Object ${JSON.stringify(invalidObject)} does not match expected schema: ${JSON.stringify(options.schema)}: ${err.toString()}. \n Please clear your local storage.`);
            }
        }
        return undefined;
    }
}
exports.default = StorageUtility;
//# sourceMappingURL=StorageUtility.js.map